Para iniciar hay que descargar el JDK de Oracle, y luego instalarlo.
Despues ajustamos las variables de entorno, para que el sistema operativo sepa donde esta el JDK, esto en 
Windows, en Linux y Mac no es necesario.

Instalar JDK en Linux

Esto es lo que hay que hacer para instalar el JDK en Linux, en este caso Ubuntu.

sudo apt-get install openjdk-7-jdk

en este caso se instala la version 7, pero se puede instalar la version 8, solo hay que cambiar 
el numero 7 por 8.

sudo apt-get install openjdk-8-jdk

Como crear una nueva clase

En nuestro editor de texto creamos un archivo con la extension .java, por ejemplo hola.java

public class hola {
    public static void main(String[] args) {
        System.out.println("Hola Mundo");
    }
}

Que es la clase main en java

La clase main es la clase principal de un programa en java, es la clase que se ejecuta cuando se ejecuta el programa.

Que es el metodo main en java

El metodo main es el metodo principal de una clase, es el metodo que se ejecuta cuando se ejecuta el programa.

Que es el metodo println en java

El metodo println es un metodo de la clase System.out, que imprime en pantalla el texto que se le pasa como parametro.

Que es el metodo print en java

El metodo print es un metodo de la clase System.out, que imprime en pantalla el texto que se le pasa como parametro.

Que es el metodo System.out en java

El metodo System.out es un metodo de la clase System, que imprime en pantalla el texto que se le pasa como parametro.

Comentarios en java

Los comentarios en java se hacen con //, por ejemplo:

// Esto es un comentario

Para comnetar varias lineas se usa /* y */ por ejemplo:

/*
Esto es un comentario
de varias lineas
*/

Comentarios orientados a la documentación (javaDoc)

Los comentarios orientados a la documentación se hacen con /** y */ por ejemplo:

/**
 * Esto es un comentario
 * de varias lineas
 */

 Podemos usar etiquetas para dar formato al texto, por ejemplo:

/**
    * Esto es un comentario
    * de varias lineas
    * @param nombre Nombre de la persona
    * @return Devuelve el nombre de la persona
    */

LAs etiquetas mas usadas son:

@param: para indicar los parametros de un metodo
@return: para indicar el valor que devuelve un metodo
@see: para indicar a que metodo hace referencia
@deprecated: para indicar que un metodo esta obsoleto
@version: para indicar la version de un metodo
@exception: para indicar las excepciones que puede lanzar un metodo
@throws: para indicar las excepciones que puede lanzar un metodo
@since: para indicar desde que version de java se puede usar un metodo
@serial: para indicar que un atributo es serializable
@serialData: para indicar que un atributo es serializable
@serialField: para indicar que un atributo es serializable

Variables en java

Las variables en java se declaran de la siguiente forma:

tipo nombre;

Por ejemplo:

int numero;
String nombre;

Las variables en java se inicializan de la siguiente forma:

tipo nombre = valor;

Por ejemplo:

int numero = 10;
String nombre = "Juan";

Tipos de datos null en java

Los tipos de datos null en java son:

null: es un valor especial que indica que la variable no tiene valor

Este valor null solo puede ser asignado a variables de tipo objeto, por ejemplo:

String nombre = null;

Tipos de datos operadores en java

Los tipos de datos operadores en java son:

Operador: Significado

+ : Suma
- : Resta
* : Multiplicacion
/ : Division
% : Modulo
++ : Incremento
-- : Decremento
+= : Suma y asignacion
-= : Resta y asignacion
*= : Multiplicacion y asignacion
/= : Division y asignacion
%= : Modulo y asignacion
== : Igual

Operadores logicos en java

Los operadores logicos en java son:

Operador: Significado

&& : AND
|| : OR
! : NOT

Para la concatenacion de cadenas se usa el operador + por ejemplo:

String nombre = "Juan";
String apellido = "Perez";
String nombreCompleto = nombre + " " + apellido;

Palabras reservadas en java

Las palabras reservadas en java son:

abstract: para definir una clase abstracta
assert: para hacer una asercion
boolean: para definir una variable booleana
break: para salir de un bucle
byte: para definir una variable byte
case: para definir un caso de un switch
catch: para capturar una excepcion
char: para definir una variable char
class: para definir una clase
const: para definir una constante
continue: para continuar con la siguiente iteracion de un bucle
default: para definir el caso por defecto de un switch
do: para definir un bucle do while
double: para definir una variable double
else: para definir un else
enum: para definir un enumerado
extends: para definir una herencia
final: para definir una clase final
finally: para definir un bloque finally
float: para definir una variable float
for: para definir un bucle for
goto: para definir un goto
if: para definir un if
implements: para definir una interfaz
import: para importar una clase
instanceof: para hacer una comprobacion de tipo
int: para definir una variable int
interface: para definir una interfaz
long: para definir una variable long
native: para definir un metodo nativo
new: para crear un objeto
package: para definir un paquete
private: para definir un atributo o metodo privado
protected: para definir un atributo o metodo protegido
public: para definir un atributo o metodo publico
return: para definir un return
short: para definir una variable short
static: para definir un atributo o metodo estatico
strictfp: para definir una clase con precision estandar
super: para hacer referencia a la superclase
switch: para definir un switch
synchronized: para definir un metodo sincronizado
this: para hacer referencia al objeto actual
throw: para lanzar una excepcion
throws: para definir las excepciones que puede lanzar un metodo
transient: para definir un atributo transient
try: para definir un bloque try
void: para definir un metodo void
volatile: para definir un atributo volatile
while: para definir un bucle while

Nomenclatura de variables y buenas prácticas

Las variables en java se declaran en minusculas, si son varias palabras se separan con guion bajo, por ejemplo:

int numero;
String nombre_completo;

TAmbien la mejor practica es usar camelCase, por ejemplo:

int numero;
String nombreCompleto;

Para las clases se usa la primera letra en mayuscula, por ejemplo:

public class HolaMundo {
    public static void main(String[] args) {
        System.out.println("Hola Mundo");
    }
}

Para los metodos se usa la primera letra en minuscula, por ejemplo:

public class HolaMundo {
    public static void main(String[] args) {
        System.out.println("Hola Mundo");
    }
}

Para las constantes se usa mayusculas, por ejemplo:

public class HolaMundo {
    public static final int NUMERO = 10;
    public static void main(String[] args) {
        System.out.println("Hola Mundo");
    }
}


Que es una funcion en java

Una funcion en java es un bloque de codigo que se puede reutilizar, por ejemplo:

public static void main(String[] args) {
    System.out.println("Hola Mundo");
}


Creacion de una funcion

Para crear una funcion en java se usa la palabra reservada public, por ejemplo:

public static void main(String[] args) {
    System.out.println("Hola Mundo");
}

Su estructura es la siguiente:

public static tipo nombre(parametros) {
    // Codigo
}

Por ejemplo:

public static int suma(int a, int b) {
    return a + b;
}

Funciones anonimas en java

Las funciones anonimas en java son funciones que no tienen nombre, por ejemplo:

public class HolaMundo {
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Hola Mundo");
            }
        }).start();
    }
}

la funcion anonima en el ejemplo anterior es:

new Runnable() {
    @Override
    public void run() {
        System.out.println("Hola Mundo");
    }
}

Esto porue no tiene nombre, se puede usar para crear un hilo.

Modificadores de acceso en java

Los modificadores de acceso en java son:

public: para definir un atributo o metodo publico 
private: para definir un atributo o metodo privado, solo es visible dentro de la clase 
protected: para definir un atributo o metodo protegido, solo es visible dentro del paquete y las subclases

Otros modificadores son:

static: para definir un atributo o metodo estatico, no necesita instanciar la clase para usarlo 
final: para definir una clase final, no se puede heredar
abstract: para definir una clase abstracta, no se puede instanciar
synchronized: para definir un metodo sincronizado
native: para definir un metodo nativo
transient: para definir un atributo transient
volatile: para definir un atributo volatile
strictfp: para definir una clase con precision estandar
void : para definir un metodo void

Ejemplo de modificador void

public static void() {
    // Codigo
}
Lo que va a hacer es ejecutar el codigo que esta dentro de la funcion, pero no va a retornar nada, por ejemplo:

public static void() {
    System.out.println("Hola Mundo");
}

Al invocar a la funcion no va a retornar nada,

Sobre carga de funciones en java

La sobre carga de funciones en java es cuando se tiene una funcion con el mismo nombre pero con diferentes parametros, por ejemplo:

public static int suma(int a, int b) {
    return a + b;
}

public static int suma(int a, int b, int c) {
    return a + b + c;
}

public static int suma(int a, int b, int c, int d) {
    return a + b + c + d;
}

Sobrecarga con distintos tipos de datos

public static int suma(int a, int b) {
    return a + b;
}

public static int suma(float a, float b) {
    return a + b;
}

if else en java

Es una estructura de control que permite ejecutar un bloque de codigo si se cumple una condicion, por ejemplo:

public static void main(String[] args) {
    int numero = 10;
    if (numero == 10) {
        System.out.println("El numero es 10");
    } else {
        System.out.println("El numero no es 10");
    }
}

else if es recomendable usarlo cuando se tienen mas de dos condiciones, por ejemplo:

public static void main(String[] args) {
    int numero = 10;
    if (numero == 10) {
        System.out.println("El numero es 10");
    } else if (numero == 20) {
        System.out.println("El numero es 20");
    } else {
        System.out.println("El numero no es 10 ni 20");
    }
}

Depuracion de codigo

Para depurar el codigo se usa la palabra reservada System.out.println(), por ejemplo:

public static void main(String[] args) {
    int numero = 10;
    System.out.println("El numero es: " + numero);
}

Podemos en algunos editores de codigo IDE como intelliJ IDEA usar breakpoints y debug para depurar el codigo.
Osea ir viendo paso a paso como se ejecuta el codigo.

Bucles en java

Bucle for

Es una estructura de control que permite ejecutar un bloque de codigo un numero determinado de veces, por ejemplo:

public static void main(String[] args) {
    for (int i = 0; i < 10; i++) {
        System.out.println("El numero es: " + i);
    }
}

Bucle while

Es una estructura de control que permite ejecutar un bloque de codigo mientras se cumpla una condicion, por ejemplo:

public static void main(String[] args) {
    int i = 0;
    while (i < 10) {
        System.out.println("El numero es: " + i);
        i++;
    }
}

Bucle do while

Es una estructura de control que permite ejecutar un bloque de codigo mientras se cumpla una condicion, pero la diferencia con el while es que este se ejecuta al menos una vez, por ejemplo:

public static void main(String[] args) {
    int i = 0;
    do {
        System.out.println("El numero es: " + i);
        i++;
    } while (i < 10);
}

Bucle foreach

Es una estructura de control que permite ejecutar un bloque de codigo para cada elemento de un array, por ejemplo:

public static void main(String[] args) {
    int[] numeros = {1, 2, 3, 4, 5};
    for (int numero : numeros) {
        System.out.println("El numero es: " + numero);
    }
}

Bucle for infinito

Es una estructura de control que permite ejecutar un bloque de codigo infinitamente, por ejemplo:

public static void main(String[] args) {
    for (;;) {
        System.out.println("Hola Mundo");
    }
}

Bucle while infinito

Es una estructura de control que permite ejecutar un bloque de codigo infinitamente, por ejemplo:

public static void main(String[] args) {
    while (true) {
        System.out.println("Hola Mundo");
    }
}

Bucle do while infinito

Es una estructura de control que permite ejecutar un bloque de codigo infinitamente, por ejemplo:

public static void main(String[] args) {
    do {
        System.out.println("Hola Mundo");
    } while (true);
}

Bucle foreach infinito

Es una estructura de control que permite ejecutar un bloque de codigo infinitamente, por ejemplo:

public static void main(String[] args) {
    int[] numeros = {1, 2, 3, 4, 5};
    for (int numero : numeros) {
        System.out.println("El numero es: " + numero);
    }
}

continue y break

Estas palabras se utilizan en los bucles para controlar el flujo del programa, por ejemplo:

public static void main(String[] args) {
    for (int i = 0; i < 10; i++) {
        if (i == 5) {
            continue;
        }
        System.out.println("El numero es: " + i);
    }
}

Aqui el continue hace que se salte el numero 5 y continue con el siguiente numero.

public static void main(String[] args) {
    for (int i = 0; i < 10; i++) {
        if (i == 5) {
            break;
        }
        System.out.println("El numero es: " + i);
    }
}

Aqui el break hace que se salte el numero 5 y salga del bucle.

Switch en java

Es una estructura de control que permite ejecutar un bloque de codigo dependiendo de una condicion, por ejemplo:

public static void main(String[] args) {
    int numero = 10;
    switch (numero) {
        case 1:
            System.out.println("El numero es 1");
            break;
        case 2:
            System.out.println("El numero es 2");
            break;
        case 3:
            System.out.println("El numero es 3");
            break;
        default:
            System.out.println("El numero no es 1, 2 o 3");
            break;
    }
}

Esta se usa cuando se tienen muchas condiciones, si se tienen pocas se recomienda usar if else.

Las clases en java

Una clase es un modelo que define un objeto, por ejemplo:

public class Persona {
    private String nombre;
    private String apellido;
    private int edad;

    public Persona(String nombre, String apellido, int edad) {
        this.nombre = nombre;
        this.apellido = apellido;
        this.edad = edad;
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public String getApellido() {
        return apellido;
    }

    public void setApellido(String apellido) {
        this.apellido = apellido;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }
}

dentro del codigo anterior podemos ver varias cosas, los elementos de una clase son:

Modificador de acceso: public
Palabra reservada: class
Nombre de la clase: Persona
Atributos: nombre, apellido, edad   
Constructor: Persona
Metodos: getNombre, setNombre, getApellido, setApellido, getEdad, setEdad

Los atributos son las caracteristicas de un objeto, por ejemplo:

private String nombre;
private String apellido;
private int edad;

Los constructores son los metodos que se ejecutan cuando se crea un objeto, por ejemplo:

public Persona(String nombre, String apellido, int edad) {
    this.nombre = nombre;
    this.apellido = apellido;
    this.edad = edad;
}

Los metodos son las acciones que puede realizar un objeto, por ejemplo:

public String getNombre() {
    return nombre;
}

public void setNombre(String nombre) {
    this.nombre = nombre;
}

public String getApellido() {
    return apellido;
}

public void setApellido(String apellido) {
    this.apellido = apellido;
}

Crear objetos en java

Para crear un objeto de una clase se usa la palabra reservada new, por ejemplo:

Persona persona = new Persona("Juan", "Perez", 20);

Este nuevo se crea a pertir de la clase que creamos anteriormente, Persona.

Sobrecarga de constructores

Es la capacidad de crear varios constructores en una clase, por ejemplo:

public class Persona {
    private String nombre;
    private String apellido;
    private int edad;

    public Persona(String nombre, String apellido, int edad) {
        this.nombre = nombre;
        this.apellido = apellido;
        this.edad = edad;
    }

    public Persona(String nombre, String apellido) {
        this.nombre = nombre;
        this.apellido = apellido;
    }

    public Persona(String nombre) {
        this.nombre = nombre;
    }

    public Persona() {
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public String getApellido() {
        return apellido;
    }

    public void setApellido(String apellido) {
        this.apellido = apellido;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }
}

En este ejemplo se crearon 4 constructores, cada uno con diferente cantidad de parametros.


Herencia en java

Es la capacidad de crear una clase a partir de otra, por ejemplo:

public class Persona {
    private String nombre;
    private String apellido;
    private int edad;

    public Persona(String nombre, String apellido, int edad) {
        this.nombre = nombre;
        this.apellido = apellido;
        this.edad = edad;
    }

    public Persona(String nombre, String apellido) {
        this.nombre = nombre;
        this.apellido = apellido;
    }

    public Persona(String nombre) {
        this.nombre = nombre;
    }

    public Persona() {
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public String getApellido() {
        return apellido;
    }

    public void setApellido(String apellido) {
        this.apellido = apellido;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }
}   

public class Empleado extends Persona {
    private double sueldo;

    public Empleado(double sueldo, String nombre, String apellido, int edad) {
        super(nombre, apellido, edad);
        this.sueldo = sueldo;
    }

    public Empleado(double sueldo, String nombre, String apellido) {
        super(nombre, apellido);
        this.sueldo = sueldo;
    }

    public Empleado(double sueldo, String nombre) {
        super(nombre);
        this.sueldo = sueldo;
    }

    public Empleado(double sueldo) {
        this.sueldo = sueldo;
    }

    public Empleado() {
    }

    public double getSueldo() {
        return sueldo;
    }

    public void setSueldo(double sueldo) {
        this.sueldo = sueldo;
    }
}

En este ejemplo se creo una clase Empleado que hereda de la clase Persona, esto quiere decir que la clase Empleado tiene todos los atributos y metodos de la clase Persona, ademas de tener sus propios atributos y metodos.

Sobreescritura en java

Es la capacidad de sobreescribir un metodo de la clase padre, por ejemplo:

public class Persona {
    private String nombre;
    private String apellido;
    private int edad;

    public Persona(String nombre, String apellido, int edad) {
        this.nombre = nombre;
        this.apellido = apellido;
        this.edad = edad;
    }

    public Persona(String nombre, String apellido) {
        this.nombre = nombre;
        this.apellido = apellido;
    }

    public Persona(String nombre) {
        this.nombre = nombre;
    }

    public Persona() {
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public String getApellido() {
        return apellido;
    }

    public void setApellido(String apellido) {
        this.apellido = apellido;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }

    @Override
    public String toString() {
        return "Persona{" + "nombre=" + nombre + ", apellido=" + apellido + ", edad=" + edad + '}';
    }
}

public class Empleado extends Persona {
    private double sueldo;

    public Empleado(double sueldo, String nombre, String apellido, int edad) {
        super(nombre, apellido, edad);
        this.sueldo = sueldo;
    }

    public Empleado(double sueldo, String nombre, String apellido) {
        super(nombre, apellido);
        this.sueldo = sueldo;
    }

    public Empleado(double sueldo, String nombre) {
        super(nombre);
        this.sueldo = sueldo;
    }

    public Empleado(double sueldo) {
        this.sueldo = sueldo;
    }

    public Empleado() {
    }

    public double getSueldo() {
        return sueldo;
    }

    public void setSueldo(double sueldo) {
        this.sueldo = sueldo;
    }

    @Override
    public String toString() {
        return "Empleado{" + "sueldo=" + sueldo + '}';
    }
}

En este ejemplo se sobreescribio el metodo toString de la clase Persona, esto quiere decir que cuando se imprima un objeto de la clase Empleado, se imprimira el metodo toString de la clase Empleado.

Polimorfismo en java

Es la capacidad de crear objetos de una clase padre y asignarlos a una variable de la clase padre, por ejemplo:

public class Persona {
    private String nombre;
    private String apellido;
    private int edad;

    public Persona(String nombre, String apellido, int edad) {
        this.nombre = nombre;
        this.apellido = apellido;
        this.edad = edad;
    }

    public Persona(String nombre, String apellido) {
        this.nombre = nombre;
        this.apellido = apellido;
    }

    public Persona(String nombre) {
        this.nombre = nombre;
    }

    public Persona() {
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public String getApellido() {
        return apellido;
    }

    public void setApellido(String apellido) {
        this.apellido = apellido;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }

    @Override
    public String toString() {
        return "Persona{" + "nombre=" + nombre + ", apellido=" + apellido + ", edad=" + edad + '}';
    }
}

public class Empleado extends Persona {
    private double sueldo;

    public Empleado(double sueldo, String nombre, String apellido, int edad) {
        super(nombre, apellido, edad);
        this.sueldo = sueldo;
    }

    public Empleado(double sueldo, String nombre, String apellido) {
        super(nombre, apellido);
        this.sueldo = sueldo;
    }

    public Empleado(double sueldo, String nombre) {
        super(nombre);
        this.sueldo = sueldo;
    }

    public Empleado(double sueldo) {
        this.sueldo = sueldo;
    }

    public Empleado() {
    }

    public double getSueldo() {
        return sueldo;
    }

    public void setSueldo(double sueldo) {
        this.sueldo = sueldo;
    }

    @Override
    public String toString() {
        return "Empleado{" + "sueldo=" + sueldo + '}';
    }
}


public class Principal {
    public static void main(String[] args) {
        Persona p1 = new Persona("Juan", "Perez", 20);
        System.out.println(p1);
        
        Empleado e1 = new Empleado(1000, "Juan", "Perez", 20);
        System.out.println(e1);
        
        Persona p2 = new Empleado(1000, "Juan", "Perez", 20);
        System.out.println(p2);
    }
}

En este ejemplo se creo un objeto de la clase Persona y un objeto de la clase Empleado, luego se creo un objeto de la clase Empleado y se asigno a una variable de la clase Persona, esto quiere decir que se puede crear un objeto de una clase hija y asignarlo a una variable de la clase padre.


Clases abstractas en java

Es una clase que no se puede instanciar, esto es que no se puede crear un objeto de esta clase, por ejemplo creamos la 
clase animal:

public abstract class Animal {
    private String nombre;
    private int edad;

    public Animal(String nombre, int edad) {
        this.nombre = nombre;
        this.edad = edad;
    }

    public Animal(String nombre) {
        this.nombre = nombre;
    }

    public Animal() {
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }

    @Override
    public String toString() {
        return "Animal{" + "nombre=" + nombre + ", edad=" + edad + '}';
    }
}

Ahora como podemos usar esa clase?

public class Perro extends Animal {
    private String raza;

    public Perro(String raza, String nombre, int edad) {
        super(nombre, edad);
        this.raza = raza;
    }

    public Perro(String raza, String nombre) {
        super(nombre);
        this.raza = raza;
    }

    public Perro(String raza) {
        this.raza = raza;
    }

    public Perro() {
    }

    public String getRaza() {
        return raza;
    }

    public void setRaza(String raza) {
        this.raza = raza;
    }

    @Override
    public String toString() {
        return "Perro{" + "raza=" + raza + '}';
    }
}

Esta puede ser usada por la clase Perro, pero no se puede instanciar un objeto de la clase Animal, solo
se puede instanciar un objeto de la clase Perro.

Digamos que las clases abstractas nos sirven para crear una clase padre que no se puede instanciar, 
pero que si puede ser usada por otras clases.

Polimorfismo en clases abstractas en java

Es la capacidad de crear objetos de una clase padre y asignarlos a una variable de la clase padre, por ejemplo:

public abstract class Animal {
    private String nombre;
    private int edad;

    public Animal(String nombre, int edad) {
        this.nombre = nombre;
        this.edad = edad;
    }

    public Animal(String nombre) {
        this.nombre = nombre;
    }

    public Animal() {
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }

    @Override
    public String toString() {
        return "Animal{" + "nombre=" + nombre + ", edad=" + edad + '}';
    }
}

public class Perro extends Animal {
    private String raza;

    public Perro(String raza, String nombre, int edad) {
        super(nombre, edad);
        this.raza = raza;
    }

    public Perro(String raza, String nombre) {
        super(nombre);
        this.raza = raza;
    }

    public Perro(String raza) {
        this.raza = raza;
    }

    public Perro() {
    }

    public String getRaza() {
        return raza;
    }

    public void setRaza(String raza) {
        this.raza = raza;
    }

    @Override
    public String toString() {
        return "Perro{" + "raza=" + raza + '}';
    }
}

Interfaces en java

Es una clase abstracta que solo tiene metodos abstractos, es decir que solo tiene metodos sin cuerpo, por ejemplo:

public interface Acciones {
    public void comer();
    public void dormir();
    public void jugar();
}

Ahora podemos crear una clase que implemente esta interfaz:

public class Perro implements Acciones {
    private String nombre;
    private int edad;

    public Perro(String nombre, int edad) {
        this.nombre = nombre;
        this.edad = edad;
    }

    public Perro(String nombre) {
        this.nombre = nombre;
    }

    public Perro() {
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }

    @Override
    public String toString() {
        return "Perro{" + "nombre=" + nombre + ", edad=" + edad + '}';
    }

    @Override
    public void comer() {
        System.out.println("El perro esta comiendo");
    }

    @Override
    public void dormir() {
        System.out.println("El perro esta durmiendo");
    }

    @Override
    public void jugar() {
        System.out.println("El perro esta jugando");
    }
}

Ahora podemos crear un objeto de la clase Perro y usar los metodos de la interfaz Acciones:

public class Principal {
    public static void main(String[] args) {
        Perro p1 = new Perro("Firulais", 2);
        p1.comer();
        p1.dormir();
        p1.jugar();
    }
}

En este ejemplo se creo un objeto de la clase Perro y se uso los metodos de la interfaz Acciones.

Arays en java

Es una estructura de datos que nos permite almacenar varios valores de un mismo tipo, por ejemplo:

public class Principal {
    public static void main(String[] args) {
        int[] numeros = new int[5];
        numeros[0] = 1;
        numeros[1] = 2;
        numeros[2] = 3;
        numeros[3] = 4;
        numeros[4] = 5;
        for (int i = 0; i < numeros.length; i++) {
            System.out.println(numeros[i]);
        }
    }
}

En este ejemplo se creo un array de enteros y se le asignaron valores, luego se recorrio el array y se imprimio cada valor.

Listas en java

Es una estructura de datos que nos permite almacenar varios valores de un mismo tipo, por ejemplo:

import java.util.ArrayList;

public class Principal {
    public static void main(String[] args) {
        ArrayList<Integer> numeros = new ArrayList<>();
        numeros.add(1);
        numeros.add(2);
        numeros.add(3);
        numeros.add(4);
        numeros.add(5);
        for (int i = 0; i < numeros.size(); i++) {
            System.out.println(numeros.get(i));
        }
    }
}

En este ejemplo se creo una lista de enteros y se le asignaron valores, luego se recorrio la lista y se imprimio cada valor.

Tambien podemos iterar la lista con un foreach:

import java.util.ArrayList;

public class Principal {
    public static void main(String[] args) {
        ArrayList<Integer> numeros = new ArrayList<>();
        numeros.add(1);
        numeros.add(2);
        numeros.add(3);
        numeros.add(4);
        numeros.add(5);
        for (Integer numero : numeros) {
            System.out.println(numero);
        }
    }
}

En este ejemplo se creo una lista de enteros y se le asignaron valores, luego se recorrio la lista y se imprimio cada valor.

Tambien podemos usar el metodo forEach de la clase ArrayList:

import java.util.ArrayList;

public class Principal {
    public static void main(String[] args) {
        ArrayList<Integer> numeros = new ArrayList<>();
        numeros.add(1);
        numeros.add(2);
        numeros.add(3);
        numeros.add(4);
        numeros.add(5);
        numeros.forEach((numero) -> {
            System.out.println(numero);
        });
    }
}

En este ejemplo se creo una lista de enteros y se le asignaron valores, luego se recorrio la lista y se imprimio cada valor.

Tambien podemos usar el metodo forEach de la clase ArrayList con una expresion lambda:

import java.util.ArrayList;

public class Principal {
    public static void main(String[] args) {
        ArrayList<Integer> numeros = new ArrayList<>();
        numeros.add(1);
        numeros.add(2);
        numeros.add(3);
        numeros.add(4);
        numeros.add(5);
        numeros.forEach(System.out::println);
    }
}

En este ejemplo se creo una lista de enteros y se le asignaron valores, luego se recorrio la lista y se imprimio cada valor.

Tambien podemos usar el metodo forEach de la clase ArrayList con una expresion lambda y un metodo de referencia:

import java.util.ArrayList;

public class Principal {
    public static void main(String[] args) {
        ArrayList<Integer> numeros = new ArrayList<>();
        numeros.add(1);
        numeros.add(2);
        numeros.add(3);
        numeros.add(4);
        numeros.add(5);
        numeros.forEach(numero -> System.out.println(numero));
    }
}

En este ejemplo se creo una lista de enteros y se le asignaron valores, luego se recorrio la lista y se imprimio cada valor.

El metodo toString 

Es un metodo que se hereda de la clase Object y se usa para convertir un objeto en una cadena de texto, por ejemplo:

public class Principal {
    public static void main(String[] args) {
        Perro p1 = new Perro("Firulais", 2);
        System.out.println(p1);
    }
}

En este ejemplo se creo un objeto de la clase Perro y se imprimio el objeto, pero como no se sobreescribio el metodo toString, se imprimio la direccion de memoria del objeto.

Para sobreescribir el metodo toString se debe usar la anotacion @Override y retornar una cadena de texto, por ejemplo:

usando @Override

public class Perro {
    private String nombre;
    private int edad;

    public Perro(String nombre, int edad) {
        this.nombre = nombre;
        this.edad = edad;
    }

    public Perro(String nombre) {
        this.nombre = nombre;
    }

    public Perro() {
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }

    @Override
    public String toString() {
        return "Perro{" + "nombre=" + nombre + ", edad=" + edad + '}';
    }

    @Override
    public void comer() {
        System.out.println("El perro esta comiendo");
    }

    @Override
    public void dormir() {
        System.out.println("El perro esta durmiendo");
    }

    @Override
    public void jugar() {
        System.out.println("El perro esta jugando");
    }
}

En este ejemplo se sobreescribio el metodo toString de la clase Perro.

Maps en java

Es una estructura de datos que nos permite almacenar varios valores de un mismo tipo, por ejemplo:

import java.util.HashMap;

public class Principal {
    public static void main(String[] args) {
        HashMap<String, String> paises = new HashMap<>();
        paises.put("Colombia", "Bogota");
        paises.put("Argentina", "Buenos Aires");
        paises.put("Peru", "Lima");
        paises.put("Chile", "Santiago");
        paises.put("Ecuador", "Quito");
        paises.forEach((key, value) -> {
            System.out.println(key + " - " + value);
        });
    }
}

En este ejemplo se creo un map de paises y se le asignaron valores, luego se recorrio el map y se imprimio cada valor.

Tambien podemos usar el metodo forEach de la clase HashMap:

import java.util.HashMap;

public class Principal {
    public static void main(String[] args) {
        HashMap<String, String> paises = new HashMap<>();
        paises.put("Colombia", "Bogota");
        paises.put("Argentina", "Buenos Aires");
        paises.put("Peru", "Lima");
        paises.put("Chile", "Santiago");
        paises.put("Ecuador", "Quito");
        paises.forEach((key, value) -> {
            System.out.println(key + " - " + value);
        });
    }
}

En este ejemplo se creo un map de paises y se le asignaron valores, luego se recorrio el map y se imprimio cada valor.

Tambien podemos usar el metodo forEach de la clase HashMap con una expresion lambda:

import java.util.HashMap;

public class Principal {
    public static void main(String[] args) {
        HashMap<String, String> paises = new HashMap<>();
        paises.put("Colombia", "Bogota");
        paises.put("Argentina", "Buenos Aires");
        paises.put("Peru", "Lima");
        paises.put("Chile", "Santiago");
        paises.put("Ecuador", "Quito");
        paises.forEach((key, value) -> System.out.println(key + " - " + value));
    }
}

En este ejemplo se creo un map de paises y se le asignaron valores, luego se recorrio el map y se imprimio cada valor.

Tambien podemos usar el metodo forEach de la clase HashMap con una expresion lambda y un metodo de referencia:

import java.util.HashMap;

public class Principal {
    public static void main(String[] args) {
        HashMap<String, String> paises = new HashMap<>();
        paises.put("Colombia", "Bogota");
        paises.put("Argentina", "Buenos Aires");
        paises.put("Peru", "Lima");
        paises.put("Chile", "Santiago");
        paises.put("Ecuador", "Quito");
        paises.forEach(System.out::println);
    }
}

En este ejemplo se creo un map de paises y se le asignaron valores, luego se recorrio el map y se imprimio cada valor.

Podemos iterar tambien usando ya sea solo las llaves o solo los valores:

import java.util.HashMap;

public class Principal {
    public static void main(String[] args) {
        HashMap<String, String> paises = new HashMap<>();
        paises.put("Colombia", "Bogota");
        paises.put("Argentina", "Buenos Aires");
        paises.put("Peru", "Lima");
        paises.put("Chile", "Santiago");
        paises.put("Ecuador", "Quito");
        paises.keySet().forEach(System.out::println);
        paises.values().forEach(System.out::println);
    }
}

En este ejemplo se creo un map de paises y se le asignaron valores, luego se recorrio el map y se imprimio cada valor.

Try catch y finally en java

El bloque try catch es usado para capturar excepciones, esto es muy util cuando se esta trabajando con archivos, 
redes, bases de datos, etc. nos ayuda a manejar los errores que se puedan presentar y evitar que el programa se 
caiga o se detenga cuando ocure un error.

Para ocuparlo usamos la palabra reservada try, seguido de un bloque de codigo, luego usamos la palabra reservada catch
y dentro de los parentesis colocamos el tipo de excepcion que queremos capturar, por ejemplo:

try {
    // codigo
} catch (Exception e) {
    // codigo
}

En este ejemplo se capturo la excepcion Exception, pero tambien podemos capturar una excepcion especifica, por ejemplo:

try {
    // codigo
} catch (IOException e) {
    // codigo
}

En este ejemplo se capturo la excepcion IOException, tambien podemos capturar multiples excepciones, por ejemplo:

try {
    // codigo
} catch (IOException | SQLException e) {
    // codigo
}

En este ejemplo se capturo la excepcion IOException y SQLException, tambien podemos capturar multiples excepciones
y una excepcion general, por ejemplo:

try {
    // codigo
} catch (IOException | SQLException e) {
    // codigo
} catch (Exception e) {
    // codigo
}

En este ejemplo se capturo la excepcion IOException y SQLException, y tambien se capturo la excepcion general Exception.

Tambien podemos usar el bloque finally, este bloque se ejecuta siempre, ya sea si se capturo una excepcion o no, por ejemplo:

try {
    // codigo
} catch (IOException | SQLException e) {
    // codigo
} catch (Exception e) {
    // codigo
} finally {
    // codigo
}

En este ejemplo se capturo la excepcion IOException y SQLException, y tambien se capturo la excepcion general Exception,
y se ejecuto el bloque finally.

Trows en java

El bloque throws es usado para indicar que un metodo puede lanzar una excepcion, esto es muy util cuando se esta trabajando con archivos,
redes, bases de datos, etc. nos ayuda a manejar los errores que se puedan presentar y evitar que el programa se
caiga o se detenga cuando ocure un error.

Para ocuparlo usamos la palabra reservada throws seguido del tipo de excepcion que puede lanzar el metodo, por ejemplo:

public void metodo() throws Exception {
    // codigo
}

En este ejemplo se indica que el metodo puede lanzar la excepcion Exception, tambien podemos indicar que el metodo puede lanzar multiples excepciones, por ejemplo:

public void metodo() throws IOException, SQLException {
    // codigo
}

En este ejemplo se indica que el metodo puede lanzar la excepcion IOException y SQLException.

Tambien podemos usar el bloque throws en la firma del metodo, por ejemplo:

public void metodo() throws IOException, SQLException;

En este ejemplo se indica que el metodo puede lanzar la excepcion IOException y SQLException.

Tambien podemos usar el bloque throws en la firma del metodo y en el cuerpo del metodo, por ejemplo:

public void metodo() throws IOException, SQLException {
    // codigo
}

Ahora bien esa es la palabra trows, pero tambien podemos usar la palabra throw, esta palabra es usada para lanzar una excepcion, por ejemplo:

public void metodo() throws IOException, SQLException {
    throw new IOException();
}

En este ejemplo se lanza la excepcion IOException.

En resumen, trows es usado para indicar que un metodo puede lanzar una excepcion, y throw es usado para lanzar una excepcion.

IO estandar en java

El IO estandar es un conjunto de clases que nos permiten leer y escribir datos, tambien nos permite leer y escribir archivos,

Para leer y escribir datos usamos la clase Scanner, para leer archivos usamos la clase FileReader, para escribir archivos usamos la clase FileWriter, para leer y escribir archivos usamos la clase BufferedReader y BufferedWriter, para leer y escribir archivos binarios usamos la clase DataInputStream y DataOutputS

Encapsulacion en java

La encapsulacion es un concepto de la programacion orientada a objetos, este concepto nos permite ocultar los detalles de implementacion de un objeto, para que solo se puedan acceder a los atributos y metodos publicos.

Para encapsular un atributo usamos la palabra reservada private, para encapsular un metodo usamos la palabra reservada private, para encapsular una clase usamos la palabra reservada private.

Para acceder a un atributo encapsulado usamos los metodos getter y setter, para acceder a un metodo encapsulado usamos los metodos getter y setter, para acceder a una clase encapsulada usamos los metodos getter y setter.

Para crear un metodo getter usamos la palabra reservada public seguido del tipo de dato que retorna el metodo, seguido del nombre del metodo, seguido de los parentesis, seguido de las llaves, por ejemplo:

public String getNombre() {
    return nombre;
}

En este ejemplo se creo un metodo getter para el atributo nombre, para crear un metodo setter usamos la palabra reservada public seguido de la palabra reservada void, seguido del nombre del metodo, seguido de los parentesis, seguido de las llaves, por ejemplo:

public void setNombre(String nombre) {
    this.nombre = nombre;
}

En este ejemplo se creo un metodo setter para el atributo nombre.

En resumen, encapsular un atributo es usar la palabra reservada private, encapsular un metodo es usar la palabra reservada private, encapsular una clase es usar la palabra reservada private, acceder a un atributo encapsulado es usar los metodos getter y setter, acceder a un metodo encapsulado es usar los metodos getter y setter, acceder a una clase encapsulada es usar los metodos getter y setter, crear un metodo getter es usar la palabra reservada public seguido del tipo de dato que retorna el metodo, seguido del nombre del metodo, seguido de los parentesis, seguido de las llaves, crear un metodo setter es usar la palabra reservada public seguido de la palabra reservada void, seguido del nombre del metodo, seguido de los parentesis, seguido de las llaves.

Herencia en java

La herencia es un concepto de la programacion orientada a objetos, este concepto nos permite crear una nueva clase a partir de una clase existente, la clase existente se llama clase padre o superclase, la nueva clase se llama clase hija o subclase.

Para heredar una clase usamos la palabra reservada extends, por ejemplo:

public class Persona extends Object {
    // codigo
}

En este ejemplo se heredo la clase Object, tambien podemos heredar multiples clases, por ejemplo:

public class Persona extends Object, Serializable {
    // codigo
}

En este ejemplo se heredo la clase Object y Serializable.

Tambien podemos heredar una clase y sobreescribir sus metodos, por ejemplo:

public class Persona extends Object {
    @Override
    public String toString() {
        return "Persona";
    }
}

En este ejemplo se heredo la clase Object y se sobreescribio el metodo toString.

para instanciar un nuevo objeto de la clase hija usamos la palabra reservada new seguido del nombre de la clase hija, seguido de los parentesis, seguido de las llaves, por ejemplo:

Persona persona = new Persona();

En resumen, heredar una clase es usar la palabra reservada extends, heredar multiples clases es usar la palabra reservada extends seguido de las clases a heredar, heredar una clase y sobreescribir sus metodos es usar la palabra reservada extends seguido de la clase a heredar, seguido de la palabra reservada @Override, seguido del metodo a sobreescribir.

Polimorfismo en java

El polimorfismo es un concepto de la programacion orientada a objetos, este concepto nos permite crear un metodo que pueda ser invocado por diferentes objetos, cada objeto puede tener su propia implementacion del metodo.

Para crear un metodo polimorfico usamos la palabra reservada @Override, por ejemplo:

public class Persona extends Object {
    @Override
    public String toString() {
        return "Persona";
    }
}

En este ejemplo se creo un metodo polimorfico, tambien podemos crear un metodo polimorfico que reciba parametros, por ejemplo:

public class Persona extends Object {
    @Override
    public String toString(String nombre) {
        return "Persona " + nombre;
    }
}

En este ejemplo se creo un metodo polimorfico que recibe un parametro.

En resumen, crear un metodo polimorfico es usar la palabra reservada @Override, crear un metodo polimorfico que recibe parametros es usar la palabra reservada @Override seguido de los parametros del metodo.

Clases abstractas en java

Las clases abstractas son clases que no pueden ser instanciadas, estas clases solo pueden ser heredadas, estas clases pueden tener metodos abstractos y metodos concretos.

Para crear una clase abstracta usamos la palabra reservada abstract, por ejemplo:

public abstract class Persona extends Object {
    // codigo
}

En este ejemplo se creo una clase abstracta, tambien podemos crear una clase abstracta que herede de otra clase abstracta, por ejemplo:

public abstract class Persona extends Object {
    // codigo
}

public abstract class Empleado extends Persona {
    // codigo
}

En este ejemplo se creo una clase abstracta que hereda de otra clase abstracta.

Para crear un metodo abstracto usamos la palabra reservada abstract, por ejemplo:

public abstract class Persona extends Object {
    public abstract void metodo();
}

En este ejemplo se creo un metodo abstracto, tambien podemos crear un metodo abstracto que reciba parametros, por ejemplo:

public abstract class Persona extends Object {
    public abstract void metodo(String nombre);
}

En este ejemplo se creo un metodo abstracto que recibe un parametro.

En resumen, crear una clase abstracta es usar la palabra reservada abstract, crear una clase abstracta que herede de otra clase abstracta es usar la palabra reservada abstract seguido de la clase a heredar, crear un metodo abstracto es usar la palabra reservada abstract, crear un metodo abstracto que recibe parametros es usar la palabra reservada abstract seguido de los parametros del metodo.

Modificador static en java

El modificador static es un modificador de acceso, este modificador nos permite acceder a un atributo o metodo sin necesidad de crear un objeto, este modificador se usa para crear variables de clase y metodos de clase.

Para crear una variable de clase usamos la palabra reservada static seguido del tipo de dato de la variable, seguido del nombre de la variable, por ejemplo:

public class Persona extends Object {
    public static int contador = 0;
}

En este ejemplo se creo una variable de clase, tambien podemos crear una variable de clase que sea final, por ejemplo:

public class Persona extends Object {
    public static final int contador = 0;
}

En este ejemplo se creo una variable de clase que es final.

Para crear un metodo de clase usamos la palabra reservada static seguido del tipo de dato que retorna el metodo, seguido del nombre del metodo, seguido de los parentesis, seguido de las llaves, por ejemplo:

public class Persona extends Object {
    public static int contador() {
        return 0;
    }
}

En este ejemplo se creo un metodo de clase, tambien podemos crear un metodo de clase que sea final, por ejemplo:

public class Persona extends Object {
    public static final int contador() {
        return 0;
    }
}

En este ejemplo se creo un metodo de clase que es final.

En resumen, crear una variable de clase es usar la palabra reservada static seguido del tipo de dato de la variable, seguido del nombre de la variable, crear una variable de clase que sea final es usar la palabra reservada static seguido de la palabra reservada final, seguido del tipo de dato de la variable, seguido del nombre de la variable, crear un metodo de clase es usar la palabra reservada static seguido del tipo de dato que retorna el metodo, seguido del nombre del metodo, seguido de los parentesis, seguido de las llaves, crear un metodo de clase que sea final es usar la palabra reservada static seguido de la palabra reservada final, seguido del tipo de dato que retorna el metodo, seguido del nombre del metodo, seguido de los parentesis, seguido de las llaves.

Vectores en java

Los vectores son una estructura de datos que nos permite almacenar multiples valores, los vectores son de tipo generico, es decir, podemos almacenar cualquier tipo de dato.

Para crear un vector usamos la palabra reservada new seguido del tipo de dato que almacenara el vector, seguido de los corchetes, seguido de la cantidad de elementos que tendra el vector, por ejemplo:

Vector <Integer> vector = new Vector();

En este ejemplo se creo un vector de tipo Integer, tambien podemos crear un vector de tipo String, por ejemplo:

Vector <String> vector = new Vector();

En este ejemplo se creo un vector de tipo String.

Para agregar un elemento al vector usamos el metodo add, por ejemplo:

Vector <Integer> vector = new Vector();

vector.add(1);

En este ejemplo se agrego el elemento 1 al vector, tambien podemos agregar un elemento al vector en una posicion especifica, por ejemplo:

Vector <Integer> vector = new Vector();

vector.add(0, 1);

En este ejemplo se agrego el elemento 1 al vector en la posicion 0.

Para obtener un elemento del vector usamos el metodo get, por ejemplo:

Vector <Integer> vector = new Vector();

vector.add(1);

int elemento = vector.get(0);

En este ejemplo se obtuvo el elemento 1 del vector, tambien podemos obtener un elemento del vector en una posicion especifica, por ejemplo:

Vector <Integer> vector = new Vector();

vector.add(0, 1);

int elemento = vector.get(0);

En este ejemplo se obtuvo el elemento 1 del vector en la posicion 0.

Para eliminar un elemento del vector usamos el metodo remove, por ejemplo:

Vector <Integer> vector = new Vector();

vector.add(1);

vector.remove(0);

En este ejemplo se elimino el elemento 1 del vector, tambien podemos eliminar un elemento del vector en una posicion especifica, por ejemplo:

Vector <Integer> vector = new Vector();

vector.add(0, 1);

vector.remove(0);

En este ejemplo se elimino el elemento 1 del vector en la posicion 0.

En resumen, crear un vector es usar la palabra reservada new seguido del tipo de dato que almacenara el vector, seguido de los corchetes, seguido de la cantidad de elementos que tendra el vector, agregar un elemento al vector es usar el metodo add, agregar un elemento al vector en una posicion especifica es usar el metodo add seguido de la posicion, obtener un elemento del vector es usar el metodo get, obtener un elemento del vector en una posicion especifica es usar el metodo get seguido de la posicion, eliminar un elemento del vector es usar el metodo remove, eliminar un elemento del vector en una posicion especifica es usar el metodo remove seguido de la posicion.

InputStream, FileInutStream

InputStream es una clase abstracta que nos permite leer datos de un archivo, FileInputStream es una clase que hereda de InputStream, esta clase nos permite leer datos de un archivo.

Para crear un objeto FileInputStream usamos la palabra reservada new seguido del nombre de la clase, seguido de los parentesis, seguido del nombre del archivo, por ejemplo:

FileInputStream archivo = new FileInputStream("archivo.txt");

En este ejemplo se creo un objeto FileInputStream, tambien podemos crear un objeto FileInputStream que reciba un objeto File, por ejemplo:

File archivo = new File("archivo.txt");

En este ejemplo se creo un objeto File

BuferInputStream

BufferedInputStream es una clase que hereda de InputStream, esta clase nos permite leer datos de un archivo.

Para crear un objeto BufferedInputStream usamos la palabra reservada new seguido del nombre de la clase, seguido de los parentesis, seguido del nombre del archivo, por ejemplo:

BufferedInputStream archivo = new BufferedInputStream("archivo.txt");

En este ejemplo se creo un objeto BufferedInputStream.

Scanner

Scanner es una clase que nos permite leer datos de un archivo, para crear un objeto Scanner usamos la palabra reservada new seguido del nombre de la clase, seguido de los parentesis, seguido del nombre del archivo, por ejemplo:

Scanner archivo = new Scanner("archivo.txt");

En este ejemplo se creo un objeto Scanner.

Tambien nos sirve para leer datos desde tecaldo, para crear un objeto Scanner usamos la palabra reservada new seguido del nombre de la clase, seguido de los parentesis, seguido de la palabra System.in, por ejemplo:

Scanner teclado = new Scanner(System.in);

En este ejemplo se creo un objeto Scanner.

PrintStream

PrintStream es una clase que nos permite escribir datos en un archivo, para crear un objeto PrintStream usamos la palabra reservada new seguido del nombre de la clase, seguido de los parentesis, seguido del nombre del archivo, por ejemplo:

PrintStream archivo = new PrintStream("archivo.txt");

En este ejemplo se creo un objeto PrintStream.

Para escribir datos en un archivo usamos el metodo println, por ejemplo:

PrintStream archivo = new PrintStream("archivo.txt");

archivo.println("Hola mundo");

En este ejemplo se escribio en el archivo "Hola mundo".

Tambien nos sirve para escribir datos en la consola, para crear un objeto PrintStream usamos la palabra reservada new seguido del nombre de la clase, seguido de los parentesis, seguido de la palabra System.out, por ejemplo:

PrintStream consola = new PrintStream(System.out);

En este ejemplo se creo un objeto PrintStream.